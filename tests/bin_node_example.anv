Node := struct {
	c : u32;
	d : u32;
};

BinNode := struct {
	a : &.own Node;
};

fn test(input : BinNode) -> i8 {
	node := Node.{c = 1; d = 2;};
	mut node_ref : &.own Node = move @alloc(node);
	
	bin1 : BinNode = BinNode.{ a = move node_ref;};
	// bin2 : BinNode = BinNode.{ a = move node_ref;};
	
	mut bin_ref : &.own BinNode = move @alloc(move bin1);

	// mut bin2 : BinNode = move @free(move bin_ref);

	mut b : i8 = 3;
	if b > 2 {
		mut bin2 : BinNode = move @free(move bin_ref);
		// t := move @free(move bin2.a);
	} else {
		// b = 4;
		mut bin2 : BinNode = move @free(move bin_ref);
	}
	b = 5;
	// mut bin_ref := @alloc(bin1);
	// TODO: Add move inst after every @memalloc
	// mut bin_ref := move @alloc(BinNode.{a = move node_ref; b = 1;});
	
	// mut bin : BinNode = move @free(move bin_ref);
	// d := @free(move bin.a);
}


// mut node1 := Node.{c = 1; d = 2;};
// mut node_ref : &.own Node = move @alloc(node);
// bin1 : BinNode = BinNode.{ a = move node_ref; b = 3;};
// mut bin_ref : &.own BinNode = move @alloc(bin1);

// mut bin2 : BinNode = move @free(move bin_ref);
// node2 : Node = move @free(move bin2.a);





/// example 2

// DllNode := struct {
//   next : ?&DllNode,
//   prev : ?&.own DllNode,
// };


// hd : ?&.own DllNode;

// hd = move null;

// while k < .. {
//   new := alloc(DllNode);
//   new.*.next = null;
//   new.*.prev = move hd;
//   hd = move new;
//   if hd |&hd_ptr| {
//     if hd.prev |&node| {
//       node.next = hd;
//     }
//   }
// }

// new_hd : ?&.own DllNode= move hd;

// while match right (move new_hd) |x: &.own DllNode|  
// { // new_hd : &.own DllNode;
//   node :DllNode = free(x); 
//   new_hd = node.prev;
// }
